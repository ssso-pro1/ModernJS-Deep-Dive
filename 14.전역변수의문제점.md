# 14. 전역 변수의 문제점

## 14.1 변수의 생명 주기

### 14.1.1 지역 변수의 생명 주기

- 변수는 선언에 의해 성생되고 할당을 통해 값을 갖는데, 선언된 위치에서 생성 및 소멸함
```jsx
function foo() {
// 지역 변수 (변수 x)의 생명주기 = 함수의 생명 주기 

// 변수 x 생성
  var x = 'local'; // 변수 x에 값 할당
  console.log(x); // local
  return x;
// 변수 x 소멸
}

foo();
console.log(x); // ReferenceError: x is not defined
```
- 지역 변수 x는 foo 함수가 호출되기 이전까지는 생성되지 않음

### 14.1.2 전역 변수의 생명 주기

- 함수와 달리 전역 코드는 명시적인 호출 없이 실행됨. 즉, 전역 코드는 함수 호출과 같이 로드되자마자 실행됨
- var 키워드로 선언한 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치함

**전역 객체**
- 전역 객체는 코드 실행 이전 단계에서 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체
- 클라이언트 사이드 환경(브라우저) 에서는 window, 서버 사이드 환경(Node.js)에서는 global 객체를 의미함
- ES11에서 globalThis 로 통일됨

## 14.2 전역 변수의 문제점
- 암묵적 결합: 변수의 유효 범위가 커지면 의도치 않게 상태 변경될 위험성 증가
- 긴 생명 주기
- 스코프 체인 상에서 종점에 존재: 전역 변수의 검색 속도가 가장 느림
- 네임스페이스 오염

## 14.3 전역 변수의 사용을 억제하는 방법

- 전역 변수를 지양하고 지역 변수를 사용하자

### 14.3.1 즉시 실행 함수
- 함수 정의와 동시에 호출되는 함수로 단 한 번만 호출됨
- 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 됨
```jsx
(function() {
  var foo = 10; // 즉시 실행 함수의 지역 변수
  // ...
}());

console.log(foo); // ReferenceError: foo is not defined
```

### 14.3.2 네임스페이스 객체
- 전역에 네임스페이스 역할을 담당할 객체를 생성 후 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법 (잘 사용하지 않음)

### 14.3.3 모듈 패턴
- 특징
  - 전역 변수의 억제
  - 캡슐화로 정보 은닉 구현
```jsx
var Counter = (function () {
  // private 변수 
  var num = 0;

  // 외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환
  return {
    increase() {
      return ++num;
    },
    decrease() {
      return --num;
    },
  };
}());

// private 변수는 외부로 노출되지 않음
console.log(Counter.name); // undefined

console.log(Counter.increase()); // 1
console.log(Counter.increase()); // 2
console.log(Counter.decrease()); // 1
console.log(Counter.decrease()); // 0
```
- 위의 예제의 즉시 실행 함수는 객체를 반환함
- 퍼블릭 멤버: 외부에 노출하고 싶은 변수나 함수를 담아 반환한 객체의 프로퍼티
- 프라이빗 멤버: 외부에 노출하고 싶지 않은 변수나 함수를 반환하는 객체에 추가하지 않으면 외부에서 접근 X

### 14.3.4 ES6 모듈
- ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공하여 더 이상 전역 변수 사용하지 않음





