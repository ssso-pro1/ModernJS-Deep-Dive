# 12. 함수

## 12.1 함수
- 함수: 일련의 과정을 문으로 구현하고 코드 블록으로 감싸 하나의 실행 단위로 정의한 것
```jsx
// 함수의 구성 요소
function add[함수이름] (x, y)[매개 변수] {
  return x + y[반환값]; [함수 몸체]
}
add(2, 5)[인수];
```

## 12.2 함수를 사용하는 이유
- 코드의 재사용
- 요지보수의 편의성
- 코드의 신뢰성
- 코드의 가독성 향상

## 12.3 함수 리터럴
- 함수는 객체 타입의 값이므로 함수 리터럴 생성 가능
```jsx
// 변수에 함수 리터럴을 할당
var f = function add(x, y) {
  return x + y;
}
```
- 일반 객체는 호출 불가능하지만 함수는 호출 가능

## 12.4 함수 정의
- 함수 정의: 함수를 호출하기 이전에 인수를 전달받을 매개변수와 실행할 문들, 그리고 반환할 값을 지정하는 것

**함수 정의 방식**
```jsx
// 1. 함수 선언문
function add(x, y) {
  return x + y;
}

// 2. 함수 표현식 (리터럴)
var add = function(x, y) }{
  return x + y;
}

// 3. Function 생성자 함수
var add = new Function('x', 'y', 'return x + y');

// 4. 화살표 함수(ES6)
var add = (x, y) => x + y;
```

**변수 선언과 함수 정의**
변수는 `선언`
함수는 `정의`
함수 선언문이 평가되면 식별자가 생성되고 함수 객체가 할당됨. 

### 12.4.1 함수 선언문

- 함수 이름을 생략 불가능
```jsx
function (x, y) {
    return x + y;
}
// SyntaxError: Function statements require a function name
- 함수 선언문은 표현식이 아닌 문임

```jsx
// 함수 선언문은 표현식이 아닌 문이므로 변수에 할당할 수 없음
// 하지만 함수 선언문이 변수에 할당되는 것처럼 보임
var add = function add(x, y) {
  return x + y;
};

// 함수 호출
console.log(add(2, 5)); // 7
```

> 이유는 자바스크립트 엔진은 코드의 문맥에 따라 다르게 해석하기 때문
> 함수 리터럴을 단독으로 사용하면 `함수 선언문`으로 해석하고
> 함수 리터럴이 값으로 평가돼야 하는 문맥이면 `함수 리터럴 표현식` 으로 해석함

```jsx
// 기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석됨
// 함수 선언문에서는 함수 이름을 생략할 수 없음
function foo() {
  console.log("foo");
}

foo();         // foo

// 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석됨
// 함수 리터럴에서는 함수 이름을 생략할 수 있음
(function bar() { // 함수 이름 bar는 함수 몸체 내에서만 참조할 수 있는 식별자이므로 함수 호출 불가 (함수를 가리키는 식별자가 없음)
  console.log("bar");
});
bar();       // ReferenceError: bar is not defined
```
- 위의 에제에서 함수 리터럴 foo는 `함수 선언문`으로 해석됨
- 그룹 연산자 () 내에 있는 함수 리터럴 bar 는 `힘수 리터럴 표현식`으로 해석됨  

- 자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당함.
- 함수는 함수 이름으로 호출하는 것이 아닌 `함수 객체를 가리키는 식별자로 호출`함
```jsx
// 식별자 var add, 함수 이름 function add
var add = function add(x, y) {
  return x + y;
};

// 식별자 add
console.log(add(2, 5)); // 7
```

### 12.4.2 함수 표현식
- 일급 객체: 자바스크립트의 함수는 값처럼 변수에 할당할 수도, 프로퍼티 값이 될 수도, 배열의 요소가 될 수 있음.
- 자바스크립트의 함수는 일급 객체임. 이는 함수를 값처럼 자유롭게 사용할 수 있다는 의미

```jsx
// 기명 함수 표현식
var add = function foo(x, y) {
  return x + y;
};

// 함수 객체를 가리키는 식별자로 호출
console.log(add(2, 5));

// 함수 이름으로 호출하면 ReferenceError가 발생한다.
// 함수 이름은 함수 몸체 내부에서만 유효한 식별자다.
// 함수를 호출할 때는 함수 이름이 아닌, 함수 객체를 가리키는 식별자를 사용해야 함
console.log(foo(2, 5)); // ReferenceError: foo is not defined
```

### 12.4.3 함수 생성 시점과 함수 호이스팅
```jsx
// 함수 참조
console.dir(add);         // f add(x, y)
console.dir(sub);         // undefined

// 함수 호출
console.log(add(2, 5));   // 7
console.log(sub(2, 5));   // TypeError: sub is not a function

// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 표현식
var sub = function (x, y) {
  return x - y;
};
```
> 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르기 때문에 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있음. 그러나 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없음.  
> 함수 선언문은 런타임 이전에 함수 객체가 먼저 생성됨.   
> 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아닌 변수 호이스팅이 발생하여 undefined 로 초기화됨

### 12.4.4 Function 생성자 함수
- Function 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하면서 new 연산자와 함께 호출하면 함수 객체를 생성해 반환함

### 12.4.5 화살표 함수
```jsx
const add = (x, y) => x + y;
console.log(add(2, 5)); // 7
```
- 화살표 함수는 생성자 함수로 사용할 수 없음
- 기존 함수와 this 바인딩 방식이 다르고, prototype 프로퍼티가 없으며 arguments 객체를 생성하지 않음

## 12.5 함수 호출

### 12.5.1 매개변수와 인수
- 매개변수(parameter)를 통해 인자(argument)를 전달함
```jsx
// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 호출
// 인수 1과 2가 매개변수 x와 y에 순서대로 할당되고 함수 몸체의 문들이 실행됨
var result = add(1, 2);
```
- 함수는 매개변수의 갯수와 인수의 갯수가 일치하는지 체크하지 않음> 이유는 자바스크립트 엔진은 코드의 문맥에 따라 다르게 해석하기 때문
> 함수 리터럴을 단독으로 사용하면 `함수 선언문`으로 해석하고
> 함수 리터럴이 값으로 평가돼야 하는 문맥이면 `함수 리터럴 표현식` 으로 해석함

```jsx
// 기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석됨
// 함수 선언문에서는 함수 이름을 생략할 수 없음
function foo() {
  console.log("foo");
}

foo();         // foo

// 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석됨
// 함수 리터럴에서는 함수 이름을 생략할 수 있음
(function bar() { // 함수 이름 bar는 함수 몸체 내에서만 참조할 수 있는 식별자이므로 함수 호출 불가 (함수를 가리키는 식별자가 없음)
  console.log("bar");
});
bar();       // ReferenceError: bar is not defined
```
- 위의 에제에서 함수 리터럴 foo는 `함수 선언문`으로 해석됨
- 그룹 연산자 () 내에 있는 함수 리터럴 bar 는 `힘수 리터럴 표현식`으로 해석됨  

- 자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당함.
- 함수는 함수 이름으로 호출하는 것이 아닌 `함수 객체를 가리키는 식별자로 호출`함
```jsx
// 식별자 var add, 함수 이름 function add
var add = function add(x, y) {
  return x + y;
};

// 식별자 add
console.log(add(2, 5)); // 7
```

### 12.4.2 함수 표현식
- 일급 객체: 자바스크립트의 함수는 값처럼 변수에 할당할 수도, 프로퍼티 값이 될 수도, 배열의 요소가 될 수 있음.
- 자바스크립트의 함수는 일급 객체임. 이는 함수를 값처럼 자유롭게 사용할 수 있다는 의미

```jsx
// 기명 함수 표현식
var add = function foo(x, y) {
  return x + y;
};

// 함수 객체를 가리키는 식별자로 호출
console.log(add(2, 5));

// 함수 이름으로 호출하면 ReferenceError가 발생한다.
// 함수 이름은 함수 몸체 내부에서만 유효한 식별자다.
// 함수를 호출할 때는 함수 이름이 아닌, 함수 객체를 가리키는 식별자를 사용해야 함
console.log(foo(2, 5)); // ReferenceError: foo is not defined
```

### 12.4.3 함수 생성 시점과 함수 호이스팅
```jsx
// 함수 참조
console.dir(add);         // f add(x, y)
console.dir(sub);         // undefined

// 함수 호출
console.log(add(2, 5));   // 7
console.log(sub(2, 5));   // TypeError: sub is not a function

// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 표현식
var sub = function (x, y) {
  return x - y;
};
```
> 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르기 때문에 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있음. 그러나 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없음.  
> 함수 선언문은 런타임 이전에 함수 객체가 먼저 생성됨.   
> 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아닌 변수 호이스팅이 발생하여 undefined 로 초기화됨

### 12.4.4 Function 생성자 함수
- Function 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하면서 new 연산자와 함께 호출하면 함수 객체를 생성해 반환함

### 12.4.5 화살표 함수
```jsx
const add = (x, y) => x + y;
console.log(add(2, 5)); // 7
```
- 화살표 함수는 생성자 함수로 사용할 수 없음
- 기존 함수와 this 바인딩 방식이 다르고, prototype 프로퍼티가 없으며 arguments 객체를 생성하지 않음

## 12.5 함수 호출

### 12.5.1 매개변수와 인수
- 매개변수(parameter)를 통해 인자(argument)를 전달함
```jsx
// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 호출
// 인수 1과 2가 매개변수 x와 y에 순서대로 할당되고 함수 몸체의 문들이 실행됨
var result = add(1, 2);
```
- 함수는 매개변수의 개수와 인수의 개수가 일치하는지 체크하지 않음
- 인수가 부족해서 인수가 할당되지 않은 매개변수의 값은 undefined
- 매개변수보다 인수가 더 많은 경우 초과된 인수는 무시됨 (arguments객체의 프로퍼티로 보관)
```jsx
function add(x, y) {
  console.log(arguments);
  // Arguments(3) [2, 5, 10, callee: f, Symbol(Symbol.iterator): f]

  return x + y;
}

add(2, 5, 10);
```

### 12.5.2 인수 확인
1. 자바스크립트 함수는 매개변수와 인수의 개수 일치 여부 확인 안 함
2. 자바스크립트는 동적 타입 언어임. 따라서 매개변수의 타입을 사전에 지정 불가

> 따라서 자바스크립트의 경우 함수를 정의할 때 적절한 인수가 전달되었는지 확인이 필요함

```jsx
function add(x, yy) {
  if (typeof x !== 'number' || typeof y !== 'number') {
    // 매개변수를 통해 전달된 인수의 타입이 부적절한 경우 에러를 발생시킴
    throw new TypeError('인수는 모두 숫자 값이어야 합니다.');
  }

  return x + y;
}

console.log(add(2));          // TypeError: 인수는 모두 숫자 값이어야 합니다
console.log(add('a', 'b'));   // TypeError: 인수는 모두 숫자 값이어야 합니다
```
- arguments 객체를 통해 인수 개수를 확인할 수도 있음
- 매개변수에 기본값을 할당하는 방법도 있음
```jsx
function add(a = 0, b = 0, c = 0) {
  return a + b + c;
}

console.log(add(1, 2, 3));   // 6
console.log(add(1, 2));      // 3
console.log(add(1));         // 1
console.log(add());          // 0
```

### 12.5.3 매개변수의 최대 개수
- 이상적인 함수는 한 가지 일만 하며 최대한 작게 만들어야 함

### 12.5.4 반환문
- `return` 뒤에 오는 표현식(반환값)으로 이뤄진 반환문을 사용해 실행 결과를 함수 외부로 반환(return) 할 수 있음
- 함수의 실행을 중단하고 함수 몸체를 빠져나감
- 반환문은 생략 가능하며 이 때 함수 몸체의 마지막 문까지 실행 후에 암묵적으로 undefined 반환함

## 12.6 참조에 의한 전달과 외부 상태의 변경
- 원시 값은 원본이 훼손되지 않고 객체는 원본이 훼손됨

## 12.7 다양한 함수의 형태

`다시 공부하기` 

### 12.7.1 즉시 실행 함수
- 함수 정의와 동시에 즉시 호출되는 함수로 단 한번만 호출되며 다시 호출 불가
```jsx
// 익명 즉시 실행 함수
(function () {
  var a = 3;
  var b = 5;
  return a *음
- 비순수 함수
  - 외부 상태에 의존하거나 외부 상태를 변경하는 함수
  - 부수 효과 있음

